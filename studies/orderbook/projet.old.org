# -*- coding: utf-8 -*-
#+TITLE: Prévision du cours du BTC à partir de l'order book
#+AUTHOR: Roland Donat
#+DATE: Projet MOSAIC

# ==============================================
# Document Configuration
# ======================
# Orgmode
:CONFIG:
#+LANGUAGE: fr
#+OPTIONS: H:3 num:nil toc:t \n:nil @:t ::t |:t ^:{} f:t TeX:t author:t d:nil timestamp:nil
#+OPTIONS: html-postamble:nil
#+STARTUP: content 
#+STARTUP: hidestars
#+DRAWERS: CONFIG OPTIONS CACHE MACROS
#+TODO: TODO(t) INPROGRESS(p) | DONE(d)
#+BIND: org-latex-table-scientific-notation "{%s}E{%s}"
# #+export_file_name: index.html
:END:

# HTML
# ----
:CONFIG:
# Org HTML Macros
#+MACRO: NEWLINE @@latex:\\@@ @@html:<br>@@
#+MACRO: HTMLFONTSIZE @@html:<font size="$2">$1</font>@@
#+MACRO: SUBTITLE @@html:<div class="slidesubtitle">$1</div>@@

# HTML options
# ------------
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://edgemind-sas.github.io/visual-identity/official_docs/css/edgemind.css" />
:END:

# ==============================================
# Document starts here
# ====================

#+ATTR_HTML: :width 50% :alt woman doing algorithmic trading with many computer, colorful detailed, white background
#+CAPTION: Image générée par Midjourney
[[./crypto_trading.png]]


* Contexte et objectifs du projet

Le Bitcoin (BTC) est une monnaie numérique décentralisée, première implémentation de la
technologie blockchain. Contrairement aux monnaies traditionnelles, le BTC n'est régulé par
aucune banque centrale ou gouvernement, mais par un réseau distribué de participants. La paire
BTC/USDT représente le taux de change entre le Bitcoin et le Tether, une crypto-monnaie dont la
valeur est généralement équivalente à un dollar américain (USDT). La prévision du prix du
Bitcoin en Tether est un sujet de grande importance pour les investisseurs et les acteurs du
monde de la finance, car elle permet d'élaborer des stratégies de trading et de gestion de
risques.  

L'order book, ou carnet d'ordres, est un registre en temps réel de tous les ordres d'achat et
de vente sur une plateforme d'échange pour une paire de devises spécifique, telle que
BTC/USDT. Il sert de mécanisme pour faciliter les transactions où les "asks" représentent les
ordres de vente et les "bids" représentent les ordres d'achat. La compréhension de la dynamique
de l'order book peut donner un aperçu précieux des intentions et comportements des acteurs du
marché, influençant ainsi les mouvements de prix. 

Les méthodes de machine learning peuvent être appliquées à l'analyse de l'order book pour
prédire le cours futur du BTC. En analysant les patterns historiques et les tendances dans les
changements de prix, les volumes d'achat et de vente, ainsi que le flux des ordres, les modèles
prédictifs peuvent être entraînés pour estimer la direction probable des mouvements de prix à
court terme. Des techniques telles que les réseaux de neurones récurrents (RNN), la régression,
les arbres de décision ou le deep learning peuvent être utilisées pour capturer les complexités
et les relations non linéaires présentes dans les données de l'order book. 

L'objectif de ce projet est triple :

1. Dans un premier temps, analyser et comprendre les données d'order book pour BTC/USDT, en identifiant les patterns clés qui pourraient influencer le prix du BTC.
2. Ensuite, appliquer et ajuster une méthode de prévision utilisant le machine learning pour prédire le cours du BTC par rapport à l'USDT.
3. Enfin, tester la méthode de prévision pour évaluer sa performance en simulant son
   application dans des conditions de marché historiques, permettant ainsi de mesurer
   l'efficacité et la fiabilité du modèle prédictif avant toute utilisation réelle. 

* Outils et compétences nécessaires

** Formation Python
Le travail requiert une maîtrise du langage Python, notamment la bibliothèque Pandas, un outil
essentiel pour la manipulation et l'analyse de données complexes. Il est donc attendu que les
participants acquièrent ou améliorent leurs compétences en programmation Python, en se
concentrant en particulier sur cette bibliothèque. 

De plus, il est crucial de se familiariser avec les principes de l'analyse financière. Cette
connaissance de base permettra de comprendre l'usage des indicateurs techniques, qui sont des
instruments fondamentaux pour l'analyse des tendances et la prédiction des mouvements futurs
sur les marchés financiers, y compris le marché des crypto-monnaies. 

Pour ceux qui cherchent à améliorer leurs compétences en Python, en particulier dans le domaine
du machine learning, la série de vidéos intitulée  [[https://www.youtube.com/watch?v=82KLS2C_gNQ&list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq][Formation Python Machine Learning]] 
disponible sur YouTube est une excellente ressource. Vous pouvez la trouver à l'adresse
suivante : Formation Python Machine Learning. Cette série de tutoriels offre un aperçu détaillé
et structuré, couvrant de nombreux concepts et techniques essentiels en machine learning qui
peuvent être appliqués à l'analyse des données financières.

Le travail est à réaliser avec le langage Python. Une montée en compétences est donc attendue en
programmation Python, particulièrement sur la bibliothèque Pandas. En outre, il sera important de se
familiariser avec le domaine de l'analyse financière pour 
comprendre comment les indicateurs techniques sont utilisés pour analyser et prédire les variations
du marché.

** Formation en finance

Pour mener à bien le travail lié à l'analyse et la prédiction des prix du BTC/USDT, une
connaissance générale de la finance quantitative est essentielle. Les participants devront
posséder ou développer une forte compréhension des concepts mathématiques et statistiques
appliqués au domaine financier, notamment en ce qui concerne les modèles de prévision,
l'évaluation des risques et la gestion de portefeuille. 

Une ressource recommandée en français est le livre "Finance Quantitative: Théorie, Applications
et Exercices Corrigés" de Roland Portait et Michel Terraza. Ce livre offre une excellente base
sur les principes de la finance quantitative, couvrant les théories sous-jacentes et leur
application pratique. 

En ce qui concerne l'order book, la maîtrise de son fonctionnement est cruciale, car il reflète
en temps réel l'état du marché et fournit des informations précieuses sur l'offre et la demande
pour le BTC. Les participants devront savoir interpréter les données du carnet d'ordres pour en
extraire des tendances et des signaux pertinentes pouvant influencer les décisions de trading. 

Un ouvrage en français traitant de ce sujet est "Le carnet d'ordres : outil d'analyse des
marchés financiers" de Laurent L. Pérochon. Cet ouvrage explique de manière détaillée le
fonctionnement des carnets d'ordres et comment les informations qu'ils contiennent peuvent être
utilisées pour comprendre les mouvements du marché. 

Ces compétences, combinées à une maîtrise du langage Python et des bibliothèques telles que
Pandas pour le traitement des données, constitueront le socle de connaissances nécessaire pour
relever les défis posés par l'analyse de l'order book et la prédiction des prix sur les marchés
des crypto-monnaies.

* Présentation des données

- *measure* : Type de mesure enregistrée ; peut être "amount" ou "price" :
  - "amount" indique la quantité de BTC offerte à la vente ou à l'achat.
  - "price" indique le prix auquel le BTC est proposé à la vente ("ask") ou à l'achat ("bid").
- *position* : Rang ou niveau de l'ordre dans le carnet d'ordres, allant de 0 à 99, où 0 correspond à la meilleure offre ou demande.
- *side* : Spécifie la nature de l'ordre dans le carnet d'ordres :
  - "ask" pour les ordres de vente.
  - "bid" pour les ordres d'achat.
- *symbol* : Indique la paire de trading, ici BTC/USDT, représentant les ordres d'achat ou de vente de Bitcoin (BTC) en échange de Tether (USDT).
- *datetime* : Date et heure exactes de l'enregistrement de l'ordre, au format ISO 8601 avec le fuseau horaire UTC.
- *value* : Selon le *measure*, représente :
  - La quantité de BTC pour la position d'ordre donnée lorsque *measure* est "amount".
  - Le prix du BTC pour la position d'ordre donnée lorsque *measure* est "price".



Un exemple de données issues du carnet d'ordres de la cotation BTC/USDT de profondeur 100 est
téléchargeable ici : [[ob_BTC_USDT_100.csv.bz2]]

Une fois téléchargé, voilà un code permettant de charger les données avec =Pandas= :
#+BEGIN_SRC python :session :results silent :exports results :tangle ob_study.py
import pandas as pd

order_book_filename = 'ob_BTC_USDT_100.csv.bz2'
order_book_df = pd.read_csv(order_book_filename, compression='bz2')
order_book_df['datetime'] = pd.to_datetime(order_book_df['datetime'])

# Afficher les premières lignes pour s'assurer qu'il a été chargé correctement
print(order_book_df.head())
#+END_SRC


#+BEGIN_SRC python :session :results silent :exports results :tangle ob_study.py
import plotly.io as pio
import plotly.express as px

# Pivoter le DataFrame pour avoir 'price' en x et 'amount' en y pour chaque 'datetime' et 'side'
order_book_pivot_df = order_book_df.pivot_table(index=['symbol', 'datetime', 'position', 'side'], 
                                     columns='measure', 
                                     values='value').reset_index()

# Supprimer le nom des colonnes de mesure pour éviter la confusion
order_book_pivot_df.columns.name = None  

range_amount = [order_book_pivot_df['amount'].quantile(0.01), order_book_pivot_df['amount'].quantile(0.99)]
range_price = [order_book_pivot_df['price'].quantile(0.01), order_book_pivot_df['price'].quantile(0.99)]

# Créer une figure d'animation avec Plotly Express
fig = px.histogram(order_book_pivot_df, 
                 x='price', 
                 y='amount', 
                 color='side', 
                 animation_frame='datetime', 
                 range_x=range_price,
                 range_y=range_amount,
                 title="Evolution de l'Order Book pour BTC/USDT au cours du temps")

# Améliorer la lisibilité
fig.update_layout(showlegend=True)


# Sauvegarder la figure en tant que fichier HTML
order_book_pivot_filename = 'order_book.html'  
pio.write_html(fig, file=order_book_pivot_filename,
               include_plotlyjs='cdn',
               full_html=False,
               config={'displayModeBar': False})

print(f"La figure a été sauvegardée en tant que {order_book_pivot_filename}")
#+END_SRC


* Notations mathématiques
   :PROPERTIES:
   :CUSTOM_ID: notations-mathématiques
   :END:

L'ordre book est un registre électronique qui liste l'ensemble des ordres d'achat et de vente pour un actif financier donné, comme une crypto-monnaie ou une action. Dans le cas de la cryptomonnaie, les notations mathématiques peuvent aider à décrire la structure et la dynamique de l'ordre book. Voici quelques notations de base :

1. **Ordres d'achat et de vente** :
   - $B(t)$ représente l'ensemble des ordres d'achat (ou "bids") à un temps $t$.
   - $A(t)$ représente l'ensemble des ordres de vente (ou "asks") à un temps $t$.

2. **Prix et quantités** :
   - Chaque ordre d'achat $b \in B(t)$ ou de vente $a \in A(t)$ peut être représenté comme un couple $(p, q)$, où $p$ est le prix et $q$ est la quantité (ou "amount").
   - Pour un ordre d'achat $b$, $p_b$ est le prix que l'acheteur est prêt à payer et $q_b$ est la quantité qu'il souhaite acheter.
   - Pour un ordre de vente $a$, $p_a$ est le prix que le vendeur demande et $q_a$ est la quantité qu'il souhaite vendre.

3. **Fonctions de l'ordre book** :
   - La fonction de demande cumulative à un prix $p$ est définie comme $D(p, t) = \sum_{b \in B(t), p_b \geq p} q_b$, c'est-à-dire la somme des quantités d'ordres d'achat dont le prix est supérieur ou égal à $p$.
   - La fonction d'offre cumulative à un prix $p$ est définie comme $S(p, t) = \sum_{a \in A(t), p_a \leq p} q_a$, c'est-à-dire la somme des quantités d'ordres de vente dont le prix est inférieur ou égal à $p$.

4. **Prix de la meilleure offre et de la meilleure demande** :
   - Le prix de la meilleure demande (ou "best bid") est le plus haut prix d'achat dans l'ordre book à un temps $t$, noté $p_b^*(t) = \max \{ p_b | b \in B(t) \}$.
   - Le prix de la meilleure offre (ou "best ask") est le plus bas prix de vente dans l'ordre book à un temps $t$, noté $p_a^*(t) = \min \{ p_a | a \in A(t) \}$.

5. **Profondeur de l'ordre book** :
   - La profondeur de l'ordre book à un niveau de prix $p$ peut être mesurée comme $L(p, t) = D(p, t) + S(p, t)$, la somme des fonctions de demande et d'offre cumulatives à ce prix.

6. **Prix médian de l'ordre book** :
   - Le prix médian $M(t)$ peut être défini comme le prix qui équilibre la demande et l'offre dans l'ordre book, où $D(M(t), t) = S(M(t), t)$.

Ces notations permettent d'exprimer mathématiquement les différentes caractéristiques de
l'ordre book et de réaliser des analyses quantitatives sur la dynamique du marché. En analysant
l'évolution de $D(p, t)$ et $S(p, t)$ au fil du temps, on peut par exemple étudier
l'impact des nouvelles informations sur le comportement des acteurs du marché et la formation
des prix. 
   
** Notions temporelles
    :PROPERTIES:
    :CUSTOM_ID: notions-temporelles
    :END:

Nous avons introduit précédemment la période d'échantillonnage des
données $\Delta t$. On note également $t_{0}$ la première date
d'échantillonnage. Dans l'exemple de données précédent, on rappelle que
$\Delta t = 5$ minutes et que $t_{0} =$ 2021-01-01 00:00:00.

Nous introduisons ensuite l'indice $p \ge 0$ permettant de référencer la
$p$ -ème période d'observation des données (cf. Figure ref:fig-ohlcv_period), i.e. entre
$t_{0} + p\Delta t$ et $t_{0} + (p+1)\Delta t$. En reprenant l'exemple
précédent, on a :
- 1er période d'observation $p = 0$ : période entre 2021-01-01 00:00:00 et 2021-01-01 00:05:00 ;
- 5ème période d'observation $p = 4$ : période entre 2021-01-01 00:20:00 et 2021-01-01 00:25:00.

#+NAME: fig-ohlcv_period
#+CAPTION: Notion de période sur les données OHLCV.
[[./ohlcv_period.png]]

  
Les données OHLCV sont notées dans la suite comme suit :
- $\text{o}_{p}$ : cotation de l'actif à l'ouverture de la période $p$, i.e. à $t = t_{0} +  p\Delta
  t$ ;
- $\text{c}_{p}$ : cotation de l'actif à la fermeture de la période $p$, i.e. à $t = t_{0} +
  (p+1)\Delta t$ ;
- $\text{h}_{p}$ : cotation maximum de l'actif sur la période $p$ ;
- $\text{l}_{p}$ : cotation mimimum de l'actif sur la période $p$ ;
- $\text{v}_{p}$ : volume échangé de l'actif la période $p$.

** Rendements
    :PROPERTIES:
    :CUSTOM_ID: rendements
    :END:

On note enfin $r_{p}$ la variation relative de la cotation d'un actif
entre deux périodes consécutives, on parle également de rendement (ou
/returns/ en anglais) sur la période $p$. Nous avons donc pour tout
$p \ge 1$ :
#+NAME: eq-def-returns
\begin{equation}
r_{p} = \frac{\text{c}_{p}}{\text{c}_{p - 1}} - 1.
\end{equation}
La quantité $r_{p}$ est donc positive si le BTC gagne en valeur par
rapport à l'USDT sur la période $p$ et négative sinon. Le rendement
représente l'indicateur principal au coeur de toutes les analyses
financières réalisées sur un actif donné.

La définition eqref:eq-def-returns porte sur un rendement entre deux
périodes successives. Cette définition peut être étendue entre deux périodes $p$ et $p + k$
données (cf. Figure ref:fig_rho_c_p_k) comme suit :
\begin{equation}
\rho_{p + k} = \frac{\text{c}_{p + k}}{\text{c}_{p-1}} - 1,
\end{equation}
avec $k \ge 0$ un nombre entier permettant de définir le nombre
de périodes futures à prendre en compte pour le calcul du rendement.

#+NAME: fig_rho_c_p_k
#+CAPTION: Illustration graphique du calcul d'un rendement de clôture.
[[./rho_c_p_k.png]]

*Exemples*

Nous illustrons les définitions précédentes sur l'extrait de cotation BTC/USDT suivant.
#+BEGIN_SRC python :session pres_data :results silent :exports code :tangle pres_data.py
import plotly.graph_objects as go

ohlcv_ex_df = ohlcv_df.head(10)
fig = go.Figure()
fig.add_trace(go.Candlestick(x=ohlcv_ex_df.index,
                             open=ohlcv_ex_df["open"],
                             high=ohlcv_ex_df["high"],
                             low=ohlcv_ex_df["low"],
                             close=ohlcv_ex_df["close"], name="OHLC"))
fig.update_layout(title="Exemple de données OHLC sur l'actif BTC/USDT",
                  yaxis_title="USDT",
                  xaxis_title="Temps",
                  xaxis_rangeslider_visible=False)

fig
#+END_SRC

#+NAME: fig_ohlcv_ex
#+BEGIN_SRC python :session pres_data :results html :exports results 
pio.to_html(fig, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


Le calcul général du rendement de clôture à $p + k$ avec =Pandas= repose sur la méthode =.shift= :
#+BEGIN_SRC python :exports code :eval no
rho_pk = ohlcv_df["close"].shift(-k)/ohlcv_df["close"].shift(1) - 1
#+END_SRC
Un calcul alternatif équivalent utilise la méthode =.pct_change= :
#+BEGIN_SRC python :exports code :eval no
rho_pk = ohlcv_df["close"].pct_change(k+1).shift(-k)
#+END_SRC
Même si à notre niveau les deux méthodes précédentes sont identiques, on privilégiera dans la suite
l'utilisation de la méthode =.pct_change= car cette dernière possède une meilleure précision
numérique. 

Calculons les rendements à $p$ et $p + 2$ :
#+BEGIN_SRC python :session pres_data :results silent :exports code :tangle pres_data.py
#rho_p = (ohlcv_ex_df["close"].shift(0)/ohlcv_ex_df["close"].shift(1) - 1).rename("returns")
#rho_p2 = (ohlcv_ex_df["close"].shift(-2)/ohlcv_ex_df["close"].shift(1) - 1).rename("returns_2")

rho_p = ohlcv_ex_df["close"].pct_change(1).shift(0).rename("returns")
# => équivalent à écrire rho_p = ohlcv_ex_df["close"].pct_change().rename("returns")

rho_p2 = ohlcv_ex_df["close"].pct_change(3).shift(-2).rename("returns_2")

rho_p_p2 = pd.concat([rho_p, rho_p2], axis=1)
rho_p_p2
#+END_SRC

#+BEGIN_SRC python :session pres_data :results html :exports results
rho_p_p2.style.format('{0:.3%}',  na_rep='').to_html()
#+END_SRC

En prenant la période $p$ = 2021-01-01T00:05:00 et un horizon $k = 0$,
le rendement de clôture $\rho_{p} = r_{p}$ correspond au
rapport entre la clôture de la période 2021-01-01T00:05:00 et la clôture
de la période 2021-01-01T00:00:00, soit :
$$
\rho_{p} = \frac{\text{c}_{p}}{\text{c}_{p-1}} = \frac{28858.94}{28975.65} - 1 \simeq -0.004028 \simeq -0.403 \%
$$

En prenant la période $p$ = 2021-01-01T00:10:00 et un horizon $k = 2$,
le rendement de clôture $\rho_{p+2}$ correspond au rapport
entre la clôture de la période 2021-01-01T00:20:00 et la clôture de la
période 2021-01-01T00:05:00, soit :
$$
\rho_{p + 2} = \frac{\text{c}_{p+2}}{\text{c}_{p-1}} = \frac{28846.46}{28858.94} - 1 \simeq -0.000432 \simeq -0.043 \%
$$

*Propriété*

Le rendement de clôture entre la période $p$ et la période $p + k$, noté $\rho_{p + k}$,
s'exprime en fonction des rendements $r_{p}, \ldots, r_{p+k}$ (cf. Équation eqref:eq-def-returns)
comme suit :
\begin{equation}
\rho_{p + k} = \prod_{i = 1}^{k} (r_{p + i} + 1) - 1
\end{equation}

Ce résultat classique s'obtient en remarquant que :
\begin{align}
\rho_{p + k} + 1 & = \frac{\text{c}_{p + k}}{\text{c}_{p-1}} \\
& = \frac{\text{c}_{p}}{\text{c}_{p - 1}} \frac{\text{c}_{p + 1}}{\text{c}_{p}} \ldots \frac{\text{c}_{p + k}}{\text{c}_{p + k - 1}} \\
& = (r_{p} + 1) (r_{p+1} + 1) \ldots (r_{p+k} + 1)
\end{align}



* Quelques ressources à consulter

L'objectif du projet consiste à expliquer les rendements futurs de la cotation BTC/USDT. En effet,
prévoir avec un bon niveau de précision les prochaines variations de la cotation du BTC/USDT,
permettrait d'élaborer des stratégies d'investissement rentables. Dans le domaine de la finance des
marchés, ce travail est réalisé par les analystes quantitatifs (également appelés /quant/).

Voici quelques ressources à consulter afin de montée en compétences dans le domaine de l'analyse
financière et du bitcoin :
- [[https://www.youtube.com/watch?v=du34gPopY5Y][Le Bitcoin et la Blockchain]]
- [[https://www.youtube.com/watch?v=XE7FKLfZzBA][La formule qui a radicalement transformé la finance mondiale [Black-Scholes]]
- [[https://www.youtube.com/watch?v=MrsjMiL9W9o][Krachs Boursiers & Tremblements De Terre]]
- [[https://www.youtube.com/watch?v=If5knyqF_0E][Les bases de L'analyse Technique]]
- [[https://www.youtube.com/watch?v=SinQRCKY328][Trading RSI sur le Bitcoin]]
  
À la lumière ces nouvelles connaissances, il peut être intéressant de relire la Section
ref:notations-mathématiques.

*Question à méditer* :
En supposons que l'on dispose d'un modèle permettant, à chaque période $p$, de prévoir le rendement
  du BTC/USDT à $k$ unités de temps dans le futur, i.e. $\rho_{p+k}$. Comment pourriez-vous utiliser cette
  information pour investir dans ce marché ? 

* Démarche générale d'analyse

#+BEGIN_SRC python :session start :results silent :exports results
import plotly.io as pio
#+END_SRC

Les paragraphes suivants présente une démarche d'analyse statistique générale d'un actif financier appliquée dans
le cas de l'analyse de la cotation BTC/USDT.

** Construction de la variable cible

Dans notre problématique, la variable cible (c.-à-d. la variable à prédire) représente les rendements futurs du BTC/USDT. Dans un
premier temps, il est donc nécessaire de décider de l'horizon futur des rendements à 
prévoir. Prenons un exemple en considérant un horizon d'une heure. Sachant que les données utilisées
sont échantillonnées avec une période de 5 min, il faut calculer à chaque période $p$ le rendement à
$p + k$ où $k = 60~\text{min} / 5~\text{min} = 12$.

Commençons par charger les données.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import pandas as pd

ohlcv_df = pd.read_csv("btc_5m_2021_2022.csv.bz2",
                       compression="bz2",
                       index_col="time")
#+END_SRC

Calculons ensuite les rendements futurs sur un horizon de 1 heure (soit $k=12$ unités de temps).
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
k_horizon = 12
returns = ohlcv_df["close"].pct_change(k_horizon+1).shift(-k_horizon).rename(f"r{k_horizon}")
#+END_SRC

** Analyse descriptive univariée
Nous pouvons alors faire une analyse univariée rapide de notre variable cible.

*Statistiques de base :*
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
returns.describe()
#+END_SRC

#+BEGIN_SRC python :session start :results html :exports results
returns.describe().to_frame().style.format('{0:.5}',  na_rep='').to_html()
#+END_SRC

#+RESULTS:
#+begin_export html
#+end_export

*Premières valeurs (1 semaine = 2016*5 min)*
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import plotly.express as px

fig_returns = px.line(returns.head(2016), title=f"Rendements du BTC/USDT à p+{k_horizon}",
                      markers=True,
                      labels=dict(
                          value=returns.name))
fig_returns.update_layout(showlegend=False)
fig_returns
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_returns, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


*Distribution*
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import plotly.express as px

fig_returns_hist = px.histogram(returns, title="Distribution des rendements du BTC/USDT à p+12",
                                labels=dict(value=returns.name))
fig_returns_hist.update_layout(showlegend=False)
fig_returns_hist
#+END_SRC

#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_returns_hist, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC

*Question à méditer* :
En tant qu'analyste quantitif, que vous apprennent ces premières analyses sur les
rendements du BTC/USDT sur un horizon futur de 1h ?


** Création des variables explicatives

Dans ce projet, nous proposons d'expliquer les variations du BTC/USDT à partir d'indicateurs
techniques financiers. Il existe un très grand nombre d'indicateurs techniques utilisés
classiquement dans le domaine de la finance. Parmi les plus connus, on trouve :
- le [[https://fr.wikipedia.org/wiki/Relative_strength_index][RSI]] (/Relative Strength Index/) ;
- le [[https://fr.wikipedia.org/wiki/MACD][MACD]] (/Moving Average Convergence Divergence/) ;
- les [[https://fr.wikipedia.org/wiki/Bandes_de_Bollinger][Bandes de Bollinger]] ;
- le [[https://fr.wikipedia.org/wiki/Stochastique_(analyse_technique)][Stochastique]].

Tous ces indicateurs se calculent à partir des données OHLCV du BTC/USDT disponibles. De plus, la
librairie =pandas_ta= (=pip install pandas_ta=) met à disposition les fonctions de calcul des principaux indicateurs
techniques.

*** Calcul de l'indicateur RSI

Le RSI est un indicateur technique permettant d'évaluer la vitesse et le changement des mouvements
de prix d'un actif. Le RSI oscille entre 0 et 100 et est principalement utilisé pour identifier les
conditions de surachat et de survente. Si l'indicateur RSI est grand (e.g. supérieur à 70), cela
suggère que l'actif est suracheté, ce qui signifie que le prix pourrait baisser à l'avenir. En
revanche, si l'indicateur est faible (e.g. inférieur à 30), cela peut indiquer que l'actif est
survendu et que le prix pourrait augmenter. 

L'indicateur RSI possède un paramètre appelé période ou fenêtre du RSI. Ce paramètre détermine le
nombre de périodes (dans notre cas une période = 5 min) à prendre en compte pour le calcul de
l'indicateur. La période du RSI influence la sensibilité de l'indicateur. Une période plus courte
rendra le RSI plus sensible aux variations de prix, produisant plus de signaux de surachat et de
survente. En revanche, une période plus longue rendra le RSI moins sensible, produisant moins de ces 
signaux, et dans ce cas, ces derniers peuvent être considérés comme plus fiables. 

*Notes :*
1. comme tous les indicateurs techniques, le RSI n'est pas parfait et ne permet pas à lui seul de
   prédire le cours futur d'un actif. En revanche, il peut être intéressant de mesurer son pouvoir
   explicatif, puis de l'utiliser en conjonction avec d'autres indicateurs techniques.
2. Il n'y a pas de "meilleure" période de RSI universelle ; le choix dépend de la stratégie
   d'investissement, de la volatilité de l'actif, et d'autres facteurs. Il est toujours recommandé
   de tester différentes périodes pour voir laquelle fonctionne le mieux pour la stratégie
   d'investissement considérée.

Calculons par exemple le RSI avec une fenêtre de 25 minutes (i.e. 5 périodes de 5 min). 
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import pandas_ta as ta

# Calcul du RSI avec une fenêtre d'un 25min (5 périodes de 5 minutes)
rsi = ta.rsi(ohlcv_df['close'], length=5)
rsi
#+END_SRC
*Notes :*
Pour calculer le RSI, vous devez avoir au moins autant de points de données que la taille
de la fenêtre spécifiée. Ceci explique pourquoi les 5 premières valeurs de la =Series= =rsi= sont
à =NaN=.

Visualisation du RSI(5) sur 1 semaine = 2016*5 min.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
fig_rsi = px.line(rsi.head(2016), title=f"{rsi.name}",
                  markers=True,
                  labels=dict(
                      value=rsi.name))
fig_rsi.update_layout(showlegend=False)
fig_rsi.update_yaxes(range=[0, 100])
fig_rsi
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_rsi, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


À ce stade, nous pouvons créer un =DataFrame= qui contiendra tous les indicateurs que nous souhaitons utiliser
pour prédire les rendements du BTC/USDT :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
indics_df = pd.DataFrame(index=ohlcv_df.index)
#+END_SRC

Ajoutons des indicateurs RSI en changeant la fenêtre de calcul :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
indics_df.ta.rsi(close=ohlcv_df["close"], length=5, append=True)
indics_df.ta.rsi(close=ohlcv_df["close"], length=10, append=True)
indics_df.ta.rsi(close=ohlcv_df["close"], length=30, append=True)
indics_df
#+END_SRC

*** Calcul de l'indicateur MFI

Le [[https://en.wikipedia.org/wiki/Money_flow_index][Money Flow Index (MFI)]] est un indicateur
variant entre 0 et 100 mesurant la pression d'achat et de vente en tenant compte 
à la fois des prix et des volumes. Un MFI élevé (proche de 100) est généralement considéré comme
synonyme d'un actif suracheté, tandis qu'un MFI faible (proche de 0) est généralement considéré
synonyme d'un actif survendu.

Calculons l'MFI sur une fenêtre de 10 unités de temps.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import pandas_ta as ta

mfi = ta.mfi(close=ohlcv_df['close'],
             high=ohlcv_df['high'],
             low=ohlcv_df['low'],
             volume=ohlcv_df['volume'],
             length=10)
#+END_SRC
*Notes :*
Le calcul de l'MFI nécessite les prix de clôture, du minimum, du maximum et les volumes échangés à
chaque période. 

Visualisation du MFI sur 1 semaine = 2016*5 min.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
fig_mfi = px.line(mfi.head(2016), title=f"{mfi.name}",
                  markers=True,
                  labels=dict(
                      value=mfi.name))
fig_mfi.update_layout(showlegend=False)
fig_mfi.update_yaxes(range=[0, 100])
fig_mfi
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_mfi, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


Calcul de différents indicateurs MFI en changeant la fenêtre de calcul :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
length_list = [5, 10, 30]
for length in length_list:
    indics_df.ta.mfi(close=ohlcv_df['close'],
                     high=ohlcv_df['high'],
                     low=ohlcv_df['low'],
                     volume=ohlcv_df['volume'],
                     length=length,
                     append=True)
#+END_SRC



*** Analyse exploratoire multivariée

Dans ce projet, le but de l'analyse exploratoire multivariée consiste à identifier d'éventuelles
liens entre les variables explicatives retenues et la
variable cible (rendements à 1h).

Pour ce faire, nous pouvons réaliser une analyse visuelle avec un diagramme en paires.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
data_pairs_df = pd.concat([indics_df, returns], axis=1)
fig_pairs = px.scatter_matrix(data_pairs_df.head(10000),
    title="Diagramme en paire")
fig_pairs
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_pairs, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC

Nous pouvons également visualiser uniquement les nuages de points de la variable cible avec les différentes
variables explicatives en y ajoutant une droite de régression linéaires (option =trendline= de la
fonction =px.scatter=).
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
data_target_features_long_df = \
    pd.melt(data_pairs_df.reset_index().head(10000),
            id_vars=["time", returns.name],
            value_vars=list(indics_df.columns),
            var_name="indic",
            value_name="indic_value",
            )
fig_target_pairs = \
    px.scatter(
        data_target_features_long_df,
        x="indic_value",
        y=returns.name,
        color="indic",
        facet_row="indic",
        trendline="ols",
        title=f"Variable cible {returns.name} en fonction d'indicateurs techniques",
    )
fig_target_pairs
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_target_pairs, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


*Questions à méditer :*
- Quelles sont les informations à retenir de cette première analyse visuelle ?
- Par quelle(s) méthode(s) poursuivre l'analyse multivariée ? 


** Modèle 1 : Premier modèle de régression linéaire univarié

Les variables explicatives et la variable cible étant quantitatives, la régression linéaire semble a
priori une méthode adéquate pour répondre à notre problématique.

Nous choisissons dans un premier temps d'expliquer les rendements à $p + 12$ (soit les rendements a
1 heure dans le futur) 
à partir de l'indicateur RSI avec une période de taille 5 en utilisant une régression linéaire. On
pose donc l'hypothèse suivante :
$$
\text{r12} = \alpha_{0} + \alpha_{1} \text{RSI5}.
$$
où $\alpha_{0} et \alpha_{1} sont les paramètres de régression à estimer à partir
des données.

Pour ce faire, nous utilisons la librairie =statsmodels= (=pip install statsmodels=).
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
import statsmodels.api as sm
#+END_SRC

On déclare notre variable cible et on construit le jeu de données contenant à la fois les variables
explicatives et la variable cible.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
var_target = f"r{k_horizon}"
# On applique un décalage d'une unité de temps aux variables explicatives
# car au début d'une période, on ne peut pas prédire un rendement futur en utilisant
# des indicateurs utilisant la valeur de clôture de cette même période. 
data_all = pd.concat([indics_df.shift(1), returns], axis=1).dropna()
target = data_all[var_target]
#+END_SRC


La régression linéaire est mise en oeuvre grâce à la classe =OLS= comme suit :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
var_features_mod1 = ["RSI_5"]

# Ajout d'une colonne de 1 afin d'ajouter le paramètre $\alpha_{0}$
features_mod1_df = sm.add_constant(data_all[var_features_mod1])

mod1 = sm.OLS(target, features_mod1_df)
mod1_res = mod1.fit()
mod1_res.summary()
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
mod1_summary_df = pd.DataFrame({"Coefficient": mod1_res.params,
                                "Écart-type": mod1_res.bse,
                                "p-values": mod1_res.pvalues})

conf_int = mod1_res.conf_int()
mod1_summary_df['IC  2.5%'] = conf_int[0]
mod1_summary_df['IC 97.5%'] = conf_int[1]

mod1_summary_df.style.format('{0:.5}',  na_rep='').to_html()
#+END_SRC

#+RESULTS:

*Questions à méditer :*
- Avez-vous bien compris pourquoi il est nécessaire de faire =indics_df.shift(1)= pour décaler les
  variables explicatives d'une unité de temps avant de
  construire le modèle de prévision des rendements ?
- À quoi sert la commande =sm.add_constant= ?
- Comment interpréter les coefficients obtenus ?


** Modèle 2 : Régression linéaire multivariée

Nous choisissons à présent d'expliquer les rendements à $p + 12$
à partir d'indicateurs RSI et MFI en utilisant toujours une régression linéaire mais cette fois-ci
multivariée :
$$
\text{r12} = \alpha_{0} + \alpha_{1} \text{RSI5} + \alpha_{2}
\text{RSI10} + \alpha_{3}\text{RSI30}+ \alpha_{4} \text{MFI5} + \alpha_{5}
\text{MFI10} + \alpha_{6}\text{MFI30}
$$
où $\alpha_{0}, \alpha_{1}, \ldots, \alpha_{6}$ sont les paramètres de régression à estimer à partir
des données.

Comme précédemment, on met en oeuvre la régression linéaire comme suit :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
var_features_mod2 = list(indics_df.columns)

# Ajout d'une colonne de 1 afin d'ajouter le paramètre $\alpha_{0}$
features_mod2_df = sm.add_constant(data_all[var_features_mod2])

mod2 = sm.OLS(target, features_mod2_df)
mod2_res = mod2.fit()
mod2_res.summary()
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
mod2_summary_df = pd.DataFrame({"Coefficient": mod2_res.params,
                                "Écart-type": mod2_res.bse,
                                "p-values": mod2_res.pvalues})

conf_int = mod2_res.conf_int()
mod2_summary_df['IC  2.5%'] = conf_int[0]
mod2_summary_df['IC 97.5%'] = conf_int[1]

mod2_summary_df.style.format('{0:.5}',  na_rep='').to_html()
#+END_SRC

#+RESULTS:

** Évaluation des modèles

*Questions :*
- Quelle approche standard d'évaluation d'un modèle prédictif connaissez-vous ?
- Cette approche est-elle adaptée dans le contexte de ce projet ?
- Du point de vue d'un analyste quantitatif, quels seraient les critères permettant de dire qu'un
  modèle est bon ou mauvais ?

Pour évaluer les modèles, nous mettons en oeuvre la démarche d'apprentissage/test usuelle. Les données
étant chronologiques, nous veillons à ce que les données d'apprentissage correspondent bien à des
données antérieures aux données de test.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
pct_train = 0.7
nb_train = int(pct_train*len(data_all))

data_all_train = data_all.iloc[:nb_train]
data_all_test = data_all.iloc[nb_train:]
target_train = data_all_train[var_target]
target_test = data_all_test[var_target]

ohlcv_train_df = ohlcv_df.loc[data_all_train.index]
ohlcv_test_df = ohlcv_df.loc[data_all_test.index]
#+END_SRC

*** Évaluation du modèle 1

Extraction des variables explicatives pour le modèle 1.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
features_mod1_train_df = sm.add_constant(data_all_train[var_features_mod1])
features_mod1_test_df = sm.add_constant(data_all_test[var_features_mod1])
#+END_SRC

Un modèle de régression linéaire est ensuite ajusté sur les données d'apprentissage.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod1_train = sm.OLS(target_train, features_mod1_train_df)
mod1_train_res = mod1_train.fit()
mod1_train_res.summary()
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
mod1_train_summary_df = pd.DataFrame({"Coefficient": mod1_train_res.params,
                                "Écart-type": mod1_train_res.bse,
                                "p-values": mod1_train_res.pvalues})

conf_int = mod1_train_res.conf_int()
mod1_train_summary_df['IC  2.5%'] = conf_int[0]
mod1_train_summary_df['IC 97.5%'] = conf_int[1]

mod1_train_summary_df.style.format('{0:.5}',  na_rep='').to_html()
#+END_SRC

#+RESULTS:

Puis, ce modèle est utilisé pour estimer des rendements à $p + 12$.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod1_target_pred = mod1_train_res.predict(features_mod1_test_df)
#+END_SRC

Il est alors possible d'évaluer les performances du modèle en utilisant un indicateur classique
comme l'erreur absolue moyenne.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod1_pred_mae = (mod1_target_pred - target_test).abs().mean()
#+END_SRC

Toutefois, dans une application d'analyse financière, l'enjeu est d'élaborer un modèle
d'investissement rentable. Par exemple, on peut chercher à évaluer la rentabilité de la stratégie
suivante : À une période $p$ donnée, si le modèle de régression linéaire prédit un rendement à $p+12$
  positif, alors un achat est effectué et on ne fait rien sinon. Si un achat est réalisé à la
période $p$, une vente a lieu à $p + 12$ obligatoirement.

La mise en oeuvre de cette stratégie se déroule comme suit :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
# Seuil d'achat
buy_thresh = 0.00
# Signaux d'achat
idx_mod1_pred_buy = mod1_target_pred > buy_thresh
# Signaux de vente
idx_mod1_pred_sell = idx_mod1_pred_buy.shift(k_horizon - 1).fillna(False)
#+END_SRC

Maintenant que nous disposons des instants d'achat et de vente de notre stratégie, nous pouvons la
backtester, c.-à-d. évaluer sa performance financière. Pour ce faire, nous allons simuler l'impact
financier des achats et des ventes de notre stratégie en utilisant les données historiques à notre
disposition.

Du point de vue du vocabulaire, on appelera /quote/ la monnaie qui sert à la cotation du
Bitcoin. Ici les Bitcoins sont valorisés en USDT, donc la monnaie /quote/ est l'USDT. On appelera
/base/ la monnaie sur laquelle on investit. Ici, il s'agit du Bitcoin, donc la monnaie /base/ est le
BTC.

Nous supposons dans la suite que nous partons d'un fond d'investissement de 1 USDT et que nous
investissons à chaque achat, la somme de 1/12 USDT.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
quote_init = 1
quote_trade_invest = 1/k_horizon
#+END_SRC

Enfin, nous utilisons la fonction de backtesting suivante permettant de calculer la performance de
notre stratégie.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
def backtest_fix_sell(
        ohlcv_df,
        idx_buy,
        idx_sell,
        quote_init=1,
        quote_trade_invest=1,
        base_name="base",
        quote_name="quote",
        buy_on="open",
        sell_on="close",
        balance_on="close",
        ):
    
    trades_quote_ob = \
        pd.Series(0, index=ohlcv_df.index, name=f"{quote_name}:ob")
    trades_base_ob = \
        pd.Series(0, index=ohlcv_df.index, name=f"{base_name}:ob")

    trades_quote_ob[idx_buy] += -quote_trade_invest
    trades_base_ob[idx_buy] = \
        quote_trade_invest/ohlcv_df[buy_on]

    trades_base_os = \
        (-trades_base_ob.shift(k_horizon - 1)\
         .rename(f"{base_name}:os"))\
         .fillna(0)
    trades_quote_os = \
        ((-trades_base_os)*\
         ohlcv_df[sell_on])\
         .rename(f"{quote_name}:os").fillna(0)

    trades_quote = (trades_quote_ob + trades_quote_os).rename(f"{quote_name}:o")
    trades_base = (trades_base_ob + trades_base_os).rename(f"{base_name}:o")
    trades_base_quote = \
        (trades_base*ohlcv_df.loc[trades_base.index, balance_on])\
        .rename(f"{base_name}-{quote_name}")
    trades_quote_balance = trades_quote + trades_base_quote
    trades_quote_balance.iloc[0] += quote_init
    trades_quote_balance = trades_quote_balance.cumsum().rename(f"{quote_name}:balance")

    trades_quote_perf = (trades_quote_balance/quote_init).rename(f"{quote_name}:perf")
    
    trades_df = pd.concat([
        trades_quote_ob,
        trades_base_ob,
        trades_quote_os,
        trades_base_os,
        trades_quote,
        trades_base,
        trades_base_quote,
        trades_quote_balance,
        trades_quote_perf,
    ], axis=1)

    return trades_df
#+END_SRC


#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod1_trades_df = \
    backtest_fix_sell(
        ohlcv_test_df,
        idx_buy=idx_mod1_pred_buy,
        idx_sell=idx_mod1_pred_sell,
        quote_init=quote_init,
        quote_trade_invest=quote_trade_invest,
        base_name="BTC",
        quote_name="USDT",
        )
#+END_SRC

Visualisation de la performance de la stratégie sur la période de test.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
fig_mod1_perf = px.line(mod1_trades_df["USDT:perf"], title=f"Modèle 1 : Performance de la stratégie",
                  markers=False,
                  labels=dict(
                      value="Performance"))
fig_mod1_perf.update_layout(showlegend=False)
fig_mod1_perf.update_yaxes(range=[0, mod2_trades_df["USDT:perf"].max()*1.05])
fig_mod1_perf.update_traces(line=dict(width=5))
fig_mod1_perf
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_mod1_perf, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC

*** Évaluation du modèle 2

La démarche d'évaluation du modèle 2 est analogue.

Extraction des variables explicatives pour le modèle 1.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
features_mod2_train_df = sm.add_constant(data_all_train[var_features_mod2])
features_mod2_test_df = sm.add_constant(data_all_test[var_features_mod2])
#+END_SRC

Création du modèle de régression linéaire.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod2_train = sm.OLS(target_train, features_mod2_train_df)
mod2_train_res = mod2_train.fit()
mod2_train_res.summary()
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
mod2_train_summary_df = pd.DataFrame({"Coefficient": mod2_train_res.params,
                                "Écart-type": mod2_train_res.bse,
                                "p-values": mod2_train_res.pvalues})

conf_int = mod2_train_res.conf_int()
mod2_train_summary_df['IC  2.5%'] = conf_int[0]
mod2_train_summary_df['IC 97.5%'] = conf_int[1]

mod2_train_summary_df.style.format('{0:.5}',  na_rep='').to_html()
#+END_SRC

#+RESULTS:

Prédiction des rendements à $p + 12$.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod2_target_pred = mod2_train_res.predict(features_mod2_test_df)
#+END_SRC

Calcul de l'erreur absolue moyenne.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
mod2_pred_mae = (mod2_target_pred - target_test).abs().mean()
#+END_SRC

Toutefois, dans une application d'analyse financière, l'enjeu est d'élaborer un modèle
d'investissement rentable. Par exemple, on peut chercher à évaluer la rentabilité de la stratégie
suivante : À une période $p$ donnée, si le modèle de régression linéaire prédit un rendement à $p+12$
  positif, alors un achat est effectué et on ne fait rien sinon. Si un achat est réalisé à la
période $p$, une vente a lieu à $p + 12$ et le rendement à $p+12$ est obtenu (positif ou négatif).

Évaluation de la stratégie d'investissement décrite dans la section précédente.
#+BEGIN_SRC python :session start :results silent :exports none :tangle start.py
buy_thresh = 0.00
idx_mod2_pred_buy = mod2_target_pred > buy_thresh
idx_mod2_pred_sell = idx_mod2_pred_buy.shift(k_horizon - 1).fillna(False)

quote_init = 1
quote_trade_invest = 1/k_horizon

mod2_trades_df = \
    backtest_fix_sell(
        ohlcv_test_df,
        idx_buy=idx_mod2_pred_buy,
        idx_sell=idx_mod2_pred_sell,
        quote_init=quote_init,
        quote_trade_invest=quote_trade_invest,
        base_name="BTC",
        quote_name="USDT",
        )
#+END_SRC

Visualisation de la performance de la stratégie sur la période de test.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
#mod2_perf = mod2_trades_trades["USDT:balance"].cumsum().rename("perf")
fig_mod2_perf = \
    px.line(mod2_trades_df["USDT:perf"], title=f"Modèle 2 : Performance de la stratégie",
            labels=dict(
                value="Performance"))
fig_mod2_perf.update_layout(showlegend=False)
fig_mod2_perf.update_yaxes(range=[0, mod2_trades_df["USDT:perf"].max()*1.05])
fig_mod2_perf.update_traces(line=dict(width=5))
fig_mod2_perf
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_mod2_perf, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC


** Comparaison des performances modèles

Nous pouvons enfin visualiser sur un même graphique les performances de nos deux modèles ainsi que
la performance naturelle du BTC/USDT sur la même période.

La performance naturelle du BTC/USDT correspond simplement à la performance d'un unique achat pour 
un USDT au début de la période de l'étude et de la vente de notre actif (en BTC) à la fin de la
période d'étude :
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
ohlcv_test_perf = (ohlcv_test_df["close"]/ohlcv_test_df["close"].iloc[0]).rename("USDT:perf")
#+END_SRC

Visualisation des performances.
#+BEGIN_SRC python :session start :results silent :exports code :tangle start.py
models_perf_df = pd.concat([
    ohlcv_test_perf.reset_index().assign(model="btc/usdt"),
    mod1_trades_df["USDT:perf"].reset_index().assign(model="modèle 1"),
    mod2_trades_df["USDT:perf"].reset_index().assign(model="modèle 2"),
    ], axis=0)

fig_models_perf = px.line(models_perf_df,
                          x="time",
                          y="USDT:perf",
                          color="model",
                          markers=False,
                          title="Comparaison des performances des stratégies",
                          labels=dict(
                              perf="Performance"))
fig_models_perf.update_yaxes(
    range=[0, models_perf_df["USDT:perf"].max()*1.05])
fig_models_perf.update_traces(line=dict(width=5))
fig_models_perf
#+END_SRC
#+BEGIN_SRC python :session start :results html :exports results
pio.to_html(fig_models_perf, include_plotlyjs="cdn",
            full_html=False,
            config={'displayModeBar': False})
#+END_SRC

